# コンセプトガイド  
## ― このワークフローをどう理解し、どう付き合うか ―

---



## 重要な前提

このドキュメントでは、以下の2つを**明確に区別**する。

- **framework repo**  
  方法論・思想・仕組み・雛形を提供するリポジトリ  
  （この `research-workflow` 自体）

- **project repo**  
  実際の研究・実験・提案書作成を行うリポジトリ  
  （framework repo を **submodule** として利用）

以降で述べる **成果物（results/, logs/run.json 等）は、すべて project repo 側に生成される**。  
framework repo には、成果物そのものは置かれない。



---

## 1. このドキュメントの目的

このドキュメントは、

- README を読んで「使えそう」と思った人が
- **設計思想を誤解せず**
- **無理に全部守ろうとして疲れない**

ための **考え方ガイド**である。

操作方法や詳細仕様ではなく、  
**どういう前提で設計され、どう付き合うべきか**を説明する。



---

## 2. このワークフローが扱う問題

研究・設計・実験の現場では、次の問題が繰り返し起きる。

- この結果、どのコード・どの設定で出た？
- なぜこの方針を選んだか、後で思い出せない
- 実験は回したが、論文や提案書にうまく繋がらない
- AIに相談した内容が履歴として残らない

このワークフローは、  
**これらを「努力」ではなく「仕組み」で防ぐ**ことを目的にしている。



---

## 3. 基本思想（最重要）

### 原理 1：共有記憶はファイルと Git だけ

- チャットは思考の場
- **記録はファイル**
- 履歴は Git

人間や LLM の記憶を、  
**再現性の拠り所にしない**。

---

### 原理 2：成果物は必ず同定できる

成果（results/）には必ず、

- **どの commit で**
- **どの設定で**
- **どう実行したか**

が紐づく。

※ `results/` や `logs/run.json` は **project repo 側にのみ存在**する。  
framework repo には、成果物そのものは置かれない。

これができない成果は **後で使えない成果**と割り切る。

##### コードバージョンを記録する理由

同一の設定（config.yaml）であっても、
ソースコードが異なれば結果は別物になる。

そのため本フレームワークでは、
すべての成果物に対して

- project repo の git commit
- （利用している場合）framework repo の git commit

を **run.json に事実として記録**する。

これは監視や管理のためではなく、
後から結果を説明・比較・再利用するための
最小限の provenance（由来）である。

---

### 原理 3：意図・判断・結果は最小でよい

長文の設計書は不要。

最低限、

- なぜやったか
- 何をしたか
- どうなったか

が分かれば十分。

このワークフローは  
**完璧な記録より、読み返せる記録**を重視する。



---

## 4. 人とAIの役割分担

この仕組みでは、AIを万能な存在とは考えない。

### Atlas（ChatGPT）
- 仮説を考える
- 結果を評価する
- 相談相手になる
- **司令書（codex_plan.md）を書く**

→ 意味・判断・言語化を担当

---

### Codex App
- 構造を整理する
- 設計や擬似コードを考える
- diff を見てレビューする

→ 構造と可読性を担当

---

### Codex CLI
- 実装する
- 実験を回す
- ファイルを変更する

→ 状態変化を担当

---

### 人間
- 保存する
- 採用する
- 捨てる
- 最終責任を持つ

→ **常に決定者**



### LLMの使い分け（迷ったらこれ）

- 考える・評価する → Atlas（ChatGPT）

- 構造を整える → Codex App

- 動かす・実験する → Codex CLI

迷ったら Atlas に戻ればOK。



---

## 5. 「司令書（codex_plan.md）」の考え方

`codex_plan.md` は、

- 仕様書
- チケット
- 設計書

ではない。

**「これから Codex に何をさせたか」を後から分かるようにするメモ**である。

- 雑でよい
- 箇条書きでよい
- 3行でもよい

重要なのは、  
**Codex が何を期待されて動いたか**が残ること。



---

## 6. なぜ安全ガードや hook があるのか

このワークフローは、

- 人は忘れる
- 人は急ぐ
- 人は雑になる

ことを **前提**に設計されている。

そのため、

- run.json が無い成果は止める
- 危険な操作は防ぐ
- 実行経路を一本化する

といった **物理的な安全装置**を入れている。

これは監視ではなく、  
**人を信用しすぎない優しさ**である。



---

## 7. フレームワーク repo の構成

framework repo には、  
**思想・仕組み・雛形のみ**が含まれる。

~~~
research-workflow/
├── README.md
├── CONCEPT.md
├── VERSION.md
├── principles.md
├── .codexrc
├── bin/
│ └── run_exp
├── hooks/
│ └── pre-commit
├── docs/
│ └── quickstart_15min.md
├── templates/
│ └── project/
│ ├── ai_context/
│ ├── experiments/
│ ├── bin/
│ └── src/
└── fw_experiments/
~~~




---

## 8. プロジェクト repo の構成（例）

project repo は、framework repo を **submodule として参照**し、  
実際の研究・実験・成果物を保持する。

~~~
project-A/
├── framework/ # submodule（research-workflow）
├── ai_context/
├── experiments/
├── logs/
├── results/
├── src/
└── bin/
~~~

成果物は **必ず project repo 側**に生成される。



---

## 9. フレームワーク研究としての位置づけ

このフレームワーク自体も、**方法論として進化**する。

一方で、各 project repo は  
**特定バージョンのフレームワークを固定して利用**する。

これにより、

- 方法論の進化
- 研究・実験の再現性

を両立する。



---

## 10. 最初から全部使わなくてよい

- ai_context を全部使う必要はない
- Judge を使わなくてよい
- LLM を使わなくても成立する

最初は、

- run_exp
- run.json
- results + git

これだけで十分。



---

## 11. このワークフローとの正しい付き合い方

- 厳密に守ろうとしない
- 破ったら「なぜ破ったか」を残す
- 面倒なら一段戻る

project repo 側では、

- `run_exp`
- git hook

を **自由に改変してよい**。

framework は参照点であり、  
利用者を縛るものではない。



---

## 12. まとめ

このワークフローは、

- 研究を速くする魔法ではない
- 良いアイデアを保証しない

ただし、

> **進めた研究が、  
> 後から使える形で残る**

ことは、かなりの確率で保証する。

それができれば、  
論文・提案書・次の研究は、自然についてくる。

---

困ったら README に戻るか、  
Atlas に相談すればよい。

考える場所は、いつでもそこにある。

